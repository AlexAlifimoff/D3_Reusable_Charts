<html>
<head>
<style>

.axis path,
.axis line {
    fill: none;
    stroke: #1F1F2E;
    stroke-opacity: 0.7;
    shape-rendering: crispEdges;

}
.axis path {
  stroke-width: 2px;
}

.axis text, .focus text {
  font-family: sans-serif;
  font-size: 11px;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 5px;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.focus circle {
  fill: crimson;
  stroke: crimson;
  stroke-width: 2px;
  fill-opacity: 15%;
}

.outter-wrapper {
    max-width: 650px;
    min-width: 304px;
    margin: 8px auto;
    background-color: #FAF7F7;/*#f9f4ee;*/
}
.outter-wrapper p {
    font-size: 16px;
    margin-top:5px;
    margin-bottom: 40px;
}
.inner-wrapper {
    position: relative;
    padding-bottom: 50%; /*This determines the ratio of the inner div*/
    width: 100%;
}

.outer-box {
    position: absolute;
    top: 0; bottom: 0; left: 0; right: 0;
}

.inner-box {
    width: 100%;
    height: 100%;
}


.legend  {
    min-width: 200px;
    display: flex;
    justify-content: flex-start;
    flex-wrap: wrap;
    font-size: 16px;
    padding: 10px 40px;
}
.legend > div {
    margin: 0px 25px 10px 0px;
    flex-grow: 0;
}
.legend p {
    display:inline;
    font-size: 0.8em;
    font-family: sans-serif;
    font-weight: 600;
}
.series-marker {
    height: 1em;
    width: 1em;
    border-radius: 35%;
    background-color: crimson;
    display: inline-block;
    margin-right: 4px;
    margin-bottom: -0.16rem;
}

@media (max-width:500px){
    .line {stroke-width: 3px;}
    .legend {font-size: 14px;}
}
</style>
<!--<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>-->
<script src="http://d3js.org/d3.v3.js" charset="utf-8"></script>
</head>
<body>

<div class="outter-wrapper" id="chart-line1">
    <div class="inner-wrapper">
        <div class="outer-box">
            <div class="inner-box"></div>
        </div>
    </div>

</div><p>Total number of sets</p>

<div class="outter-wrapper" id="chart-line2"><div class="inner-wrapper"><div class="outer-box">
    <div class="inner-box" ></div>
</div></div></div><p>Average unique to total piece ratio</p>


<div class="outter-wrapper" id="chart-line3"><div class="inner-wrapper"><div class="outer-box">

    <div class="inner-box" ></div>
</div></div></div><p>Average Piece Count per Set</p>

<div class="outter-wrapper" id="chart-line4"><div class="inner-wrapper"><div class="outer-box">
    <div class="inner-box" ></div>
</div></div></div><p>Std Deviation of Piece Count</p>

<footer>
<script type="text/javascript">
    d3.csv('http://localhost:8000/lego/setinfo201505.csv',
        function(error, data) {
            histogramData.forEach(function(d) {
                d.year = +d.year;
                d.num_sets = +d.num_sets;
                d.unique_to_total = +d.unique_to_total;
                d.avg_piece_count = +d.avg_piece_count;
                d.piece_count_std = +d.piece_count_std;
            });

            var cys =   {
                        'Number of Sets': {column:'num_sets'},
                        'Average Piece Count':{column:'avg_piece_count'}
                        }
            var chart1 = makeLineChart(histogramData, 'year',cys)
              .bind("#chart-line1")
              .render();

            var chart2 = makeLineChart(histogramData, 'year',{'Unique to Total':{column:'unique_to_total'}});
            chart2.bind("#chart-line2");
            chart2.render();

            var cys = {'Average Piece Count':{column:'avg_piece_count'}};
            var chart3 = makeLineChart(histogramData, 'year', cys);
            chart3.bind("#chart-line3");
            chart3.yFormatter = chart3.formatAsNumber;
            chart3.render();

            var chart4 = makeLineChart(
                histogramData, 'year',
                {
                    'Piece Cound StDev':{column:'piece_count_std'},
                    'Average Piece Count':{column:'avg_piece_count'},
                    'Number of Sets':{column:'num_sets'}
                }
            );
            chart4.bind("#chart-line4");
            chart4.render();

        });


    function makeLineChart(dataset, xName, yObjs) {
        var obj = {};
        var color  = d3.scale.category10()
        // var clrs = ['steelblue','seagreen','crimson','chocolate','yellowgreen'];
        /*
        yObjsects format:
        {y1:{column:'',name:'name',color:'color'},y2}
        */

        obj.histogramData = dataset;
        obj.margin = {top:15, right: 60, bottom: 30, left: 50};
        obj.width = 650 - obj.margin.left - obj.margin.right;
        obj.height = 480 - obj.margin.top - obj.margin.bottom;

        // So we can pass the x and y as strings when creating the function
        obj.xFunct = new Function('d', 'return d.'+xName);

      // For each yObjs argument, create a yFunction
        function getYFn(column) {
            return function (d) {
                return d[column];
            };
        };

        // Object instead of array
        obj.yFuncts =  []
        for (y in yObjs) {
            yObjs[y].name = y
            yObjs[y].yFunct = getYFn(yObjs[y].column); //Need this  list for the ymax function
            obj.yFuncts.push(yObjs[y].yFunct);
        };

      //Formatter functions for the axes
        obj.formatAsNumber = d3.format(".0f");
        obj.formatAsDecimal = d3.format(".2f");
        obj.formatAsCurrency = d3.format("$.2f");
        obj.formatAsFloat = function (d) {
            if(d % 1 != 0) {
                return d3.format(".2f")(d);
            } else {
                return d3.format(".0f")(d);
            };
        };

        obj.xFormatter = obj.formatAsNumber
        obj.yFormatter = obj.formatAsFloat

        obj.bisectYear = d3.bisector(obj.xFunct).left; //< Can be overridden in definition

        //Create scale functions
        obj.xScale = d3.scale.linear()
            .range([0, obj.width])
            .domain(d3.extent(obj.histogramData, obj.xFunct)); //< Can be overridden in definition

      // Get the max of every yFunct
        obj.max = function (fn) {return d3.max(obj.histogramData, fn)};
        obj.yScale = d3.scale.linear()
            .range([obj.height, 0])
            .domain([0, d3.max(obj.yFuncts.map(obj.max))]);

        obj.formatAsYear = d3.format("");

        //Create axis
        obj.xAxis = d3.svg.axis()
            .scale(obj.xScale)
            .orient("bottom")
            .tickFormat(obj.xFormatter); //< Can be overridden in definition

        obj.yAxis = d3.svg.axis()
            .scale(obj.yScale)
            .orient("left")
            .tickFormat(obj.yFormatter); //< Can be overridden in definition


        // Build line building functions
        function getYScaleFn(yObj) {
            return function (d) {
                return obj.yScale(yObjs[yObj].yFunct(d));
            };
        };
        for (yObj in yObjs) {
            yObjs[yObj].line = d3.svg.line()
                .interpolate("cardinal")
                .x(function (d) {return obj.xScale(obj.xFunct(d)); })
                .y(getYScaleFn(yObj));
        };

        obj.svg

        // Change chart size according to window size
        obj.update_svg_size = function () {
            obj.width = parseInt(d3.select(obj.selector).style("width"),10) - (obj.margin.left + obj.margin.right);

            obj.height = parseInt(d3.select(obj.selector).style("height"),10) - (obj.margin.top + obj.margin.bottom);

            /* Update the range of the scale with new width/height */
            obj.xScale.range([0, obj.width]);
            obj.yScale.range([obj.height, 0]);

            if (!obj.svg) {return false;}

            /* Else Update the axis with the new scale */
            obj.svg.select('.x.axis')
                .attr("transform", "translate(0," + obj.height + ")")
                .call(obj.xAxis);
            obj.svg.select('.x.axis .label')
                .attr("x", obj.width);

            obj.svg.select('.y.axis')
                .call(obj.yAxis);

            /* Force D3 to recalculate and update the line */
            for (y in yObjs) {
                yObjs[y].path.attr("d", yObjs[y].line);
            };

            d3.select(obj.selector).select('svg')
                .attr("width", obj.width + (obj.margin.left + obj.margin.right))
                .attr("height", obj.height + (obj.margin.top + obj.margin.bottom));

            obj.svg.select(".overlay")
                .attr("width", obj.width + (obj.margin.left + obj.margin.right))
                .attr("height", obj.height + (obj.margin.top + obj.margin.bottom));
            return obj;
        };

        obj.selector = ""

        obj.bind = function (selector) {
            obj.mainSelector = selector; //Used for the  legened
            obj.mainDiv = d3.select(obj.mainSelector);
            obj.selector = selector+" .inner-box";
            obj.chartDiv = d3.select(obj.selector)
            d3.select(window).on('resize.'+obj.selector,obj.update_svg_size);
            obj.update_svg_size();
            return obj;
        };

        // Render the chart
        obj.render = function () {
            //Create SVG element
            obj.svg = d3.select(obj.selector)
                .append("svg")
                .attr("class", "chart-area")
                .attr("width", obj.width + (obj.margin.left + obj.margin.right))
                .attr("height", obj.height + (obj.margin.top + obj.margin.bottom))
                .append("g")
                .attr("transform", "translate(" + obj.margin.left + "," + obj.margin.top + ")");

            // Draw Lines
            for (y in yObjs) {
                yObjs[y].path = obj.svg.append("path")
                    .datum(obj.histogramData)
                    .attr("class", "line")
                    .attr("d", yObjs[y].line)
                    .style("stroke", color(y))
                    .attr("data-series",y)
                    .on("mouseover", function() {focus.style("display", null);})
                    .on("mouseout", function() {focus.transition().delay(700).style("display", "none");})
                    .on("mousemove", mousemove);
            };

            // Draw Axis
            obj.svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + obj.height + ")")
                .call(obj.xAxis)
                .append("text")
                    .attr("class", "label")
                    .attr("x", obj.width)
                    .attr("y", 30)
                    .style("text-anchor", "end")
                    .text("Years");

            obj.svg.append("g")
                .attr("class", "y axis")
                .call(obj.yAxis)
                .append("text")
                    .attr("class", "label")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -42)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .text("Price Per Piece");

            //Draw tooltips
            var focus = obj.svg.append("g")
                .attr("class", "focus")
                .style("display", "none");
            focus.append("circle")
                .attr("r", 6);
            focus.append("text")
                .attr("x", 9)
                .attr("dy", ".35em");

            //Draw legend
            var legend = obj.mainDiv.append('div')
                .attr("class","legend")
            for (y in yObjs) {
                series = legend.append('div');
                series.append('div')
                    .attr("class", "series-marker")
                    .style("background-color",color(y));
                series.append('p')
                    .text(y);
                console.log(y);
                yObjs[y].legend = series;
            };
            return obj;

        // How to update this for hover? Get closest x? show all at an x value?
            function mousemove() {
                var x0 = obj.xScale.invert(d3.mouse(this)[0]),
                    i = obj.bisectYear(obj.histogramData, x0, 1), //<
                    d0 = obj.histogramData[i - 1],
                    d1 = obj.histogramData[i],
                    d = x0 - obj.xFunct(d0) > obj.xFunct(d1) - x0 ? d1 : d0;
                var seriesObj = yObjs[this.attributes["data-series"].value]
                focus.attr("transform", "translate(" + obj.xScale(obj.xFunct(d)) + "," + obj.yScale(seriesObj.yFunct(d)) + ")");
                focus.select("text").text(obj.xFormatter(obj.xFunct(d))+": "+obj.yFormatter(seriesObj.yFunct(d)));
            };
        };
    return obj;
    };

</script>
</footer>
</body>
</html>
